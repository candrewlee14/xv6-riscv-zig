// Much of this code comes from https://github.com/binarycraft007/xv6-riscv-zig

const std = @import("std");
const mem = std.mem;
const SyscallGenStep = @This();
const Step = std.Build.Step;

step: Step,
output_file: std.Build.GeneratedFile,
syscalls: []const []const u8,

pub fn create(owner: *std.Build, syscalls: []const []const u8) *SyscallGenStep {
    const self = owner.allocator.create(SyscallGenStep) catch unreachable;
    self.* = .{
        .step = Step.init(.{
            .id = .custom,
            .name = "generate syscall assembly",
            .owner = owner,
            .makeFn = make,
        }),
        .syscalls = syscalls,
        .output_file = .{ .step = &self.step },
    };
    return self;
}

pub fn getLazyPath(self: *SyscallGenStep) std.Build.LazyPath {
    return .{ .generated = &self.output_file };
}

fn make(step: *Step, prog_node: *std.Progress.Node) !void {
    _ = prog_node;
    const b = step.owner;
    const self: *SyscallGenStep = @fieldParentPtr("step", step);
    const gpa = b.allocator;
    const arena = b.allocator;

    var man = b.graph.cache.obtain();
    defer man.deinit();

    // Random bytes to make ConfigHeaderStep unique. Refresh this with new
    // random bytes when ConfigHeaderStep implementation is modified in a
    // non-backwards-compatible way.
    man.hash.add(@as(u32, 0xdef08d23));

    var output = std.ArrayList(u8).init(gpa);
    defer output.deinit();

    const w = output.writer();

    try w.print(
        \\# generated by build.zig - do not edit
        \\#include "kernel/syscall.h"
        \\
    , .{});

    for (self.syscalls) |syscall| {
        try w.print(".global {0s}\n{0s}:\n li a7, SYS_{0s}\n ecall\n ret\n", .{syscall});
    }

    man.hash.addBytes(output.items);

    if (try step.cacheHit(&man)) {
        const digest = man.final();
        self.output_file.path = try b.cache_root.join(arena, &.{
            "o", &digest, "usys.S",
        });
        return;
    }

    const digest = man.final();

    // If output_path has directory parts, deal with them.  Example:
    // output_dir is zig-cache/o/HASH
    // output_path is libavutil/avconfig.h
    // We want to open directory zig-cache/o/HASH/libavutil/
    // but keep output_dir as zig-cache/o/HASH for -I include
    const sub_path = try std.fs.path.join(arena, &.{ "o", &digest, "usys.S" });
    const sub_path_dirname = std.fs.path.dirname(sub_path).?;

    b.cache_root.handle.makePath(sub_path_dirname) catch |err| {
        return step.fail("unable to make path '{}{s}': {s}", .{
            b.cache_root, sub_path_dirname, @errorName(err),
        });
    };

    b.cache_root.handle.writeFile(sub_path, output.items) catch |err| {
        return step.fail("unable to write file '{}{s}': {s}", .{
            b.cache_root, sub_path, @errorName(err),
        });
    };

    self.output_file.path = try b.cache_root.join(arena, &.{sub_path});
    try man.writeManifest();
}
